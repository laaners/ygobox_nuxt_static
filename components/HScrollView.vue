<template>
	<div class="scroll-view">
		<transition name="fade">
			<div
				v-if="isPrevVisible"
				class="opacity-bar-left"
				aria-hidden="true"
			></div>
		</transition>

		<div
			ref="container"
			class="scroll-snap-container"
			@scroll="handleScroll()"
			@mousewheel="wheelScroll"
		>
			<slot />
		</div>

		<transition name="fade">
			<div
				v-if="isNextVisible"
				class="opacity-bar-right"
				aria-hidden="true"
			></div>
		</transition>

	</div>
</template>

<script>
export default {
	name: "HScrollView",
	props: {
		invert: {
			type: Boolean,
			required: false,
		},
	},
	data: () => ({
		// Use local state to dynamically toggle element visibility
		// instead of using selectors and CSS. Set defaults here.
		isPrevVisible: false,
		isNextVisible: false,
	}),
	mounted() {
		this.handleScroll()
		window.addEventListener("resize", this.handleScroll, false)
	},
	// See Vue Issue: https://github.com/vuejs/vue/issues/1915
	beforeUnmount() {
		window.removeEventListener("resize", this.handleScroll, false)
	},
	methods: {
		wheelScroll(e) {
			e.preventDefault()
			const container = this.$refs.container
			//	console.log(this.$el.querySelector(".scroll-snap-container > *").offsetWidth)
			container.scrollLeft += 208 * Math.sign(e.deltaY)
		},
		// Determines visibility of button arrows <- / ->
		handleScroll() {
			const container = this.$refs.container
			if (container === undefined) return
			this.isPrevVisible = container.scrollLeft > 0
			// The sum amounts to zero when the container is scrolled to the right end
			// scrollWidth = full scrollable length
			// scrollLeft = how much you have scrolled from the left
			// offsetWidth = basically the remaining width :)
			this.isNextVisible =
				container.scrollWidth -
					container.scrollLeft -
					container.offsetWidth >
				1
		},
	},
}
</script>

<style scoped>
@import "@/assets/styles/animations.css";
.scroll-view {
	width: 100%;
	display: flex;
	position: relative;
	margin: var(--space-1) 0;
	/* Local variables  */
	--scroll-button-size: 3rem;
}

/*Container and scrollbar styles */
.scroll-snap-container {
	display: flex;
	width: 100%;
	overflow-x: auto;
	scroll-behavior: smooth;
	scroll-snap-type: x mandatory;
	padding: 0;
}
/* Elements and opacity bars styles */
.scroll-snap-container > * {
	scroll-snap-align: center;
	scroll-margin-left: 0;
	min-width: 13em;
	margin-right: 1em;
}
.scroll-snap-container > *:last-child {
	margin-right: 0;
}
/* Styles for images */
.scroll-snap-container > img {
	height: var(--image-highlight-height);
	border-radius: var(--border-radius);
	background-color: var(--color-neutral);
	object-fit: cover;
}
.opacity-bar-right,
.opacity-bar-left {
	position: absolute;
	width: 4vw;
	/* width: 2em; */
	height: 100%;

	z-index: 1;
}
.opacity-bar-right {
	right: -0.15em;
	background: linear-gradient(
		270deg,
		var(--color-light) 35.53%,
		rgba(214, 214, 177, 0) 100%
	);
}
.opacity-bar-left {
	left: -0.15em;
	background: linear-gradient(
		90deg,
		var(--color-light) 0%,
		rgba(214, 214, 177, 0) 100%
	);
}
/*Media query */
@media only screen and (min-width: 840px) {
	.scroll-view {
		/* Local variables override */
		--scroll-button-offset-multiplier: -0.5;
	}
	.scroll-snap-container > * {
		scroll-snap-align: start;
		/* Offset from the align ('start' in this case) */
		scroll-margin-left: var(--scroll-button-size);
	}
	.prev {
		left: calc(-0.25 * var(--scroll-button-size));
	}
	.next {
		right: calc(-0.25 * var(--scroll-button-size));
	}
}
</style>
